//
//  B-Tree.swift
//  CommendLine-Swift
//
//  Created by jingwei on 2025/9/10.
//

import Foundation

/*
 B树 - 平衡的多路搜索树
 
 B树和二叉搜索树
 
 假设有M阶B树
 那么这颗B树
 
 包含的内容数量 x
 根结点是 1 ≤ x ≤ m - 1 个数量
 非跟节点。必须是有 ┌ m/2 ┐ - 1 ≤ x ≤ m - 1 个 子节点
 
 节点数量
 根结点是 2 ≤ y ≤ m 子节点
 非跟节点。必须是有 ┌ m/2 ┐ ≤ y ≤ m  个 子节点
 
 5阶B树 内容数量是在 2-4之间

 如果有子节点，子节点个数 y = x + 1
 */
// TODO: - 子节点个数必须是内容 + 1

/*
 这就不是一颗 B 🌲。子节点应该有4个
  [10, 20, 30]
 /    |
[5]  [15]
 
 即任何一棵红黑树都可以对应一棵 4 阶 B 树，反之亦然，两者在查询、插入、删除的效率上具有相同的渐进复杂度（O (log n)）。
 
 1. 红黑树 → 4 阶 B 树的转换规则
 黑色节点：对应 4 阶 B 树的 “核心节点”（存储关键字的主节点）；
 红色节点：必须与其父节点（黑色）合并，共同构成 4 阶 B 树的一个 “超级节点”（一个 4 阶 B 树节点最多包含 3 个关键字，对应红黑树中 “1 个黑节点 + 2 个红子节点” 的结构）。
 
 */
// TODO: - 红色节点：必须与其父节点（黑色）合并
class B_Tree<T> {
    //MARK: - 添加
    /*
     感觉有点像倒着分裂
     4阶
     依次加入 1 - 22
     
             1
           
            1-2
           
            1-2-3
           
              2
          1      3-4
     
             2
         1      3-4-5
          
               2-4
         1      3     5-6
     
               2-4
         1      3     5-6-7
     
              2-4-6
         1      3    5  7-8
 
         【  2  4   6】
          /   /   \    \
         1   3     5  【7 8 9】
     

     
     
     
              2-4
          1    3     5
           
              2-4
          1    3     5-6
           
               4
           2      6
          1 3    5 7
     */
    //MARK: - 删除
    /*
     需要考虑 下溢
     办法：
     1.如果兄弟节点数量足够多 可以借一下节点。旋转
     2.如果兄弟节点数量 不够 那么就需要 父节点下移 【父节点和父节点和孩子合并】 【导致 父节点和两个孩子合并】
     
     */

}

